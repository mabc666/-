# 传输层知识总结
- 传输层的基本服务
- 传输层的复用与分解
- 停-等协议与滑动窗口协议
- 用户数据包协议（UDP）
- 传输控制协议（TCP）
---
### 一、传输层的基本服务  
1、传输层所提供的服务：  
- 传输层寻址  
- 对应用层的报文进行分段和重组  
- 对报文进行差错检测  
- 实现进程间的端到端可靠数据传输控制  
- 面向应用层实现复用和分解  
- 实现端到端的流量控制  
- 拥塞控制  
  
2、传输层寻址与端口  
首先要解决的问题是如何将一个数据报传输到指定的主机上，这是通过IP地址来实现完成的，IP地址唯一标识了进程运行在哪个主机上。  
这里还要解决的问题是当一个数据报传到传输层以后如何确定这个数据报到底是属于哪个应用程序的这时候就引申出了端口号这个概念。每个应用会绑定一个端口号然后凡是数据报中端口号为该数值时，就将该数据报送给对应端口号的应用程序。  
端口号是一个16位的二进制数字，可以表示的范围是0\~65535一般0\~1023号端口为大家通用服务所提供的端口，1024\~49151为没有熟知的端口号，49152\~65535为客户端或短暂端口号，留给客户进程或用户开发非标准服务器所使用。  

3、无连接服务和面向连接的服务  
其实这两种服务无连接服务就是指的UDP，而面向连接的服务指的是TCP。无连接的服务具体是指发送数据前无需进行连接的建立，即从应用层接收到数据以后直接发送出去。而面向连接的服务是指发送数据前首先要在发送端和接收端之间建立一个可靠的连接之后在发送。  

### 二、传输层的复用与分解  
首先要在这里说明一下什么叫复用就是当应用层把数据传到传输层的时候如何区分不同的数据报，分解就是传输层应该把数据报中的数据交给应用层中的哪个应用。  
1、这里所要解决的问题非常简单，就是要解决多个应用程序如何一起工作的时候，不产生冲突。上面提到了传输层通过IP地址+端口号来明确传输的方向和由哪个应用来接收数据报。假设当一台主机运行着多个网络程序的时候首先来看UDP是如何工作的，因为UDP传输数据前无需进行连接的建立所以这里就通过一个二元组来标志一个UDP的套接字<目的IP地址，目的端口号>这样就可以进行传输了不同的应用仅仅通过不同的目的端口就可以区分开来。然后在说说TCP是如何进行复用分用的，TCP的套接字由一个四元组来标识，<目的IP地址，目的端口号，源IP地址，源端口号>通过指定这4个参数的，就可以对传输层进行复用和分用了。  
  
### 三、停-等协议与滑动窗口  
1、可靠数据传输的基本原理  
- 差错检验：通过在数据报中添加冗余的校验信息看看是否发生位错误。（循环冗余，校验和）
- 确认：接收方每次接收到数据后，返回一个确认信息来确认数据已经正确接收到了。
- 重传：当数据传输发生了错误或者数据丢失的时候，发送方会重传该数据报。
- 序号：序号是指每次发送的数据报都是由序号的，来标明数据报的前后顺序。
- 计时器：发送端每次发送数据报的时候都会启动一个定时器，如果在定时器时间到的时候还没有收到对应报文的确认信息就进行重传。

2、停-等协议  
停-等协议：发送方发送一个数据报以后就开始等待对方返回一个ACK，如果超时或者收到NAK的话就进行重传，直到收到一个正确的ACK后才发送下一个数据报。基于这种重传机制的可靠数据传输协议称为ARQ（自动重传协议）。  
**差错检验**在ARQ中的应用，在ARQ中当接收方检测出数据产生了位差错的话会发送一个NAK给接收方通知接收方进行重传。但是通常实际的传输协议中不用NAK，因为这样增加传输层的复杂程度，其实当你收到一个错误的数据报后，只要发送上一个确认的ACK给接收方，接收方就可以知道它刚刚传送的数据出现的差错然后进行重传。  
**序列号**在ARQ中其实并不是非常重要由于ARQ是停-等协议每次就传送一个数据报，所以只需要1bit（0和1），就可以了。  
**定时器**在ARQ中，当数据包在传送的过程中丢失以后，发送方会因为迟迟收不到ACK导致定时器超时，然后发送方就会重传该数据报。相同的是如果返回的ACK丢失的话也会引起发送端的定时器超时然后重传。还有一种情况就是当定时器时间设置的过短的话，其实ACK并没有丢失而是延迟到达，接收端直接重发了该数据报，等到过了一会以后重发的数据报的ACK没有回来但是延迟的ACK却到达了那么接收端就会发送下一个数据报，发送端收到重复的数据报的话直接丢弃然后重新发送一遍ACK，这样的话会导致下面的数据报会产生大量的重传，浪费资源。  

3、滑动窗口协议  
由于停-等协议每次只传送一个数据包所以该协议的传输效率太低，因此就有了滑动窗口协议的产生。滑动窗口采用了流水线的思想，一次发送多个数据报。  
首先发送方和接收方都维护这一个窗口，整个窗口的全部内容由下面几个部分组成。首先是已经发送和接收到其正确ACK的部分，这部分是已经完成传输的部分我们不需要去过分的关注。还有就是窗口部分，窗口部分又由已经发送但未接收到ACK的部分和下一个等待发送的部分。具体的窗口见如下所示：  
![image](http://img.it610.com/image/product/eab4e9b2626a4a988366f27741083a87.png)  

下面有两个典型的滑动窗口协议：  
#### GBN协议  
首先说下什么叫GBN（go back N）这个协议简单点来说就是当计时器超时以后，将滑动窗口中已发送但未收到确认的数据报全部进行重新传输。    
这里对发送方有一定的要求要求是发送方有比较大的缓存空间来存储还未收到确认的数据报，但是通常GBN协议的接收端都是无缓存能力的。因此GBN协议的发送端窗口大小要大于等于1，接收端的窗口大小等于1。  
GBN发送方需要响应的3种类型的事件：  
1、上层的调用。当上层调用GBN时会检测窗口是否已满，如果满了那就暂时不响应上层的调用，但是如果窗口还是有空间的话那么用下一个可用序号来对新的分组编号并发送出去，然后更新下一个可用序号。  
2、收到一个ACKn。GBN采用累计确认的机制，当发送方接收到一个正确的ACK那么滑动窗口前移。如果当GBN只使用ACK作为确认信号的时候，当接收端收到失序的报文后可能会重新发送多个相同的序号的ACK那么发送端不予理会。  
3、计时器超时。GBN协议发送方只使用一个计时器，并且这个计时器就是对当前窗口已发送但未收到确认中最小的那个分组序号进行计时。如果它迟迟没有收到正确的ACK，那么等到计时器超时之后，发送发会重传所有已经发送但为收到确认的分组。这就是为什么这个协议叫GBN。如果正确收到ACK后滑动窗口向前移动计时器会对其后的分组进行重新计时。  
GBN接收方的操作就比较简单了只需要检测接收到的数据包是否是按序和正确，如果不是按序和正确的话那么就发送上一个ACK序号给接收方。
GBN只适用于差错率低，切对接收方缓存能力较低的场合使用，如果误码率和差错率高的话那么信道中会产生大量的重复不必要的数据。  
#### SR协议  
由于GBN协议有一些缺点，当误码率比较高的时候效率较低。所以就想出了一种比较合理的协议-选择确认协议（SR），之所以叫选择确认是指接收方接受到正确的数据报（在接收窗口内）以后就将其存储起来，不管其顺序准不准确。如果是准确的顺序的话那么窗口就立即向前移，如果其顺序不准确的话那就等到其收到一定顺序的数据报后连接成一段又顺序的分组后一次性确认后窗口一次性向前移动。  
SR相比于GBN要求接收方要有比较大的缓存区用于存放窗口中乱序到达的数据。  
SR发送方要响应的3个事件：  
1、上层调用。这里的上层调用其实和上面GBN的上层调用一样。  
2、定时器超时。这里就和GBN不同了因为采用选择确认机制以后它会对每个已经发送出去的分组设一个定时器。如果哪个定时器超时的话那就重传该分组。  
3、收到ACKn。发送方收到ACK后，如果不是按序到达的ACK那么就在窗口中将其标出来已经接收到该分组的确认信息等到能够将所期望的ACK和没按序到达的ACK连起来后那就将滑动窗口前移，如果接收到的是按序到达的分组那么就直接将窗口前移。   

SR接收方主要操作：  
1、如果接收到的分组没有错误的话，并且分组在接收窗口内，那么就将接收窗口内该分组标记为已接收并发送相应的ACK。  
2、如果接收到窗口左侧的分组的话那么有可能就是ACK返回的时候丢失了或者延迟到达了，导致发送方的重传。那么接收方就直接丢弃该分组然后发送一个对应的ACK防止发送方死锁（窗口因为这个分组不前移）。  
3、其他情况，接收方直接丢弃分组，不做任何响应。  
滑动窗口于序号空间有一定的要求：  
Ws+Wr<=2^k  
Ws<=2^k-1  
关于信道利用率的计算公式（GBN和SR都适用）：  
Usender = Ws*Tseg/Tseg+RTT+Tack  
Tseg发送方发送报文的时间  
Tack接收方接收报文的时间  
对于GBN来说Ws=1  
### 四、用户数据报协议（UDP）
UDP相对于TCP有一下几点好处：
虽然UDP提供的服务是不可靠的，但是它的速度相对于TCP是快的，因为它无需进行连接的建立和拆除以及拥塞控制。并且其相对于主机的开销比较小，因为它无需进行状态的保存，从应用层拿到数据以后就封装一下直接交给网络层，而且它的头部相对于TCP的头部要小,TCP为20字节，UDP为8个字节。  
UDP报文段结构：

![image](http://s15.sinaimg.cn/bmiddle/006V5LiXzy7fPMcGksmde&690)

UDP校验和  
UDP也提供了差错检测的功能，也就是说UDP的校验和用于检测UDP报文段从源传送到目的地之间有没有发生位错。  
计算校验和的时候要引进一个伪头部是从网络层提取出来的用于计算校验和  
![image](http://images.51cto.com/files/uploadimg/20121229/1110530.jpg)  
计算校验和步骤：  
1.把伪首部添加到UDP上；  
2.计算初始时是需要将检验和字段添零的；  
3.把所有位划分为16位（2字节）的字  
4.把所有16位的字相加，如果遇到进位，则将高于16字节的进位部分的值加到最低位上，举例，0xBB5E+0xFCED=0x1 B84B，则将1放到最低位，得到结果是0xB84C  
5.将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和checksum。  

### 五、传输控制协议（TCP）  
首先来看下TCP的报文段的结构：  
![image](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1532603589024&di=e79fce0f3cea256401c8749cc072bcfd&imgtype=0&src=http%3A%2F%2Ffreeloda.blog.51cto.com%2Fattachment%2F201305%2F31%2F2033581_13699703243Z7C.jpg) 
首先来说下TCP报文段包括以下几点内容：
- 16位源端口号
- 16位目的端口号
- 32位序列号
- 32位确认号
- 4位首部长度（一般为5单位为4字节）
- URG：紧急指示位当URG=1时，通知系统该报文段中有紧急数据，应尽快传送 。 
- ACK：标识确认号字段有效，当ACK=0时，确认序号字段无效。  
- PSH：当PSH=1时，传输层立即将数据交复给应用层不必等缓存满。
- RST: 当RST=1时，表明TCP连接中出现了严重的问题，必须释放连接，然后重连
- SYN：当SYN=1时，表示该TCP报文段是一个建立新连接请求控制段，或者是同意建立连接请求的确认段
- FIN：FIN是用来释放TCP连接的标志。具体看后面的连接管理
- 窗口大小：用于向对方通告接收窗口大小，表示接收方还愿意接收的应用层数据量，其值根据本地缓存剩余空间来设置。
- 检验和
- 紧急指针：紧急指针指出紧急数据最后一个字节在数据中的位置。
- 选项字段：TCP最初只规定了一种选项即TCP通告其缓存能够接收的数据段最大的长度是MSS个字节（MSS指的是应用层的数据不包括头部信息）。还有就是包括窗口扩大选项（3字节）其中一个字节表示位移值S（允许最大值为14位），新的接收窗口值等于TCP首部中的窗口大小的值左移S位后的值。时间戳选项（10字节），其中最主要的字段有时间戳字段（4字节）和时间戳回送回答字段（4字节）。选择性确认选项（SACK），TCP默认采用累计确认机制，如果使用选择性确认的话，那么在建立TCP连接的时，要在TCP首部的选项上加入“允许SACK”的选项，而双方必须都先商定好，该选项基本不用。
- 填充字段：用于填0充使选项的大小位32位。  
#### TCP连接管理  
连接的建立和拆除如图所示：  
![image](https://ww2.sinaimg.cn/large/006tKfTcgy1fdilnjr84mj30zk0lk788.jpg) 

![image](https://ww3.sinaimg.cn/large/006tKfTcgy1fdilpjw72ej31180ou43x.jpg) 

解释一下三次握手的必要性为什么要选择三次握手而不是二次握手，因为二次握手的话，如果接收方的应答ACK丢失的话，发起的一方会认为连接没有建立起来而接收的那一方认为连接已经建立起来了，所以会出现无效连接。还有一种情况就是当发送方之前发送的请求在传输过程中延迟到达了，而发送端由于超时重新发送了一个请求并关闭了之前的那个请求，但是接收端收到先前那个请求之后返回了一个ACK那么，这一连接属于半连接（只有一方建立了连接），但是服务器已经为其分配了资源，还有可能收到错误的信息。  

关于连接关闭中的TIME_WAIT状态解释：  
当被动关闭者发送最后一个FIN之后主动发起者要进入TIME_WAIT状态(持续2个报文最长存活时间MSL)，首先进入这个状态是必要的。因为被动关闭者总是会重传FIN，直到收到ACK为止。如果没有这个状态，主动关闭方的ACK在传输过程中丢失的话，那么被动关闭方就没办法正确的关闭。  
还有一点是如果没有这个状态，主动关闭方发送FIN然后接受到ACK就直接把连接关闭的话，这里面有一个问题。假设网络中有一些延迟的数据包还没到达，如果它立马又与刚刚那个被动接收方建立了一个连接并且恰巧这个连接与上一个连接的几个连接参数（客户ip，客户端口，服务器ip，服务器端口）相同的话，那通信端将会搞不清这到底是上次的还是这次的数据包.TIME_WAIT这个状态会锁定这一组连接参数，使其不能立马被其他连接所用，而且延迟的数据包将会被丢弃。

#### TCP可靠数据传输  
TCP的可靠数据传输依靠的是：差错编码、确认、序号、重传、计时器等  
差错编码：靠检验和来检测传输过程中是否发生了位差错。  
确认：在TCP中的ACK中包含的是下一个所期望的收到的分组序号，并且采用累计确认的机制。  
序号：是每个字节编号。   
重传：重传数据数据主要针对两类事件计时器超时和三次重复确认。   
计时器：采用单一的重传计时器，并且采用自适应算法设置超时时间。  
TCP的可靠传输都是靠滑动窗口协议实现的，并且这个窗口会动态调整，根据基于流量控制的接收窗口大小RcvWin和基于拥塞控制的拥塞控制窗口CongWin中取小的那个值。  
首先来说下TCP的大致工作流程：  
1、应用数据被分割成TCP认为最合适的发送的数据块（MSS），封装成TCP段，传给网络层。  
2、当TCP发出去一个段后，立即启动定时器。  
3、TCP首部设有校验和，如果接收端发现校验和不对的话就丢弃这个报文，然后向发送端发送一个最希望收到的那个分组的ACK请求（即接已经接收并确认的分组+1的那个分组）。  
4、TCP会对接收到的乱序报文进行重新排序以后按正确的顺序交付给应用层。  
5、如果接收端收到重复的报文的话，那么将重复的报文直接丢弃。  
6、TCP能够提供流量控制，即接收端会将自己的缓存空间告诉发送端让发送端不要发送过多的分组而导致的缓存区溢出。  

首先说下定时器的时间设置问题具体如何推算出来详见书本下面只给出公式：  
EstimatedRTT = (1-&) * EstimatedRTT + & * SampleRTT  
DevRTT = （1-β）* DevRTT + β * |SampleRTT - EstimatedRTT|  
TimeoutInterval = EstimatedRTT + 4 * DevRTT  
TCP定时器超时以后会把定时器的时间设置为原来的两倍,为了防止过早的超时导致不必要的重传,然后根据收到应用层的数据或者收到ACK后重启定时器的时候会重新根据上面几个公式来设定定时器时间。  

##### TCP确认机制和快速重传原理  
1、首先说下TCP可以采用一个ACK来确认多个分组当有多个连续分组等待发送ACK的话那么就发送序号最大的那个分组的ACK来进行一次性的确认。  
2、如果期望序号之前的所有分组都确认掉了以后，TCP会延迟发送ACK，最多等待500ms，为了减少ACK的发送可以等待一会然后一次性确认多个分组。  
3、如果收到失序的报文，那么立即发送重复ACK即发送ACK请求当前所期望的那个分组，然后那个失序的报文可以丢弃也可以保留下来具体根据TCP的实现来定。  
快速重传是指当一次传输多个分组，突然其中有一个分组丢失然后TCP的接收端因为丢失的那个分组而发送多个重复的ACK，这时接收端收到重复ACK的时候可能定时器还没有超时，那接收端就判定分组丢失了继而重传那个丢失了的分组。  

##### TCP流量控制  
其实TCP的流量控制就是接收端给发送端发送ACK的时候，在报文段中，通知自己的缓冲区还可以接收多少数据。    
流量控制是对于端到端之间的控制不同于下面要讲的拥塞控制，拥塞控制是从大局或者说是整个网络来考虑的。  

##### TCP拥塞控制  
TCP拥塞控制也是基于窗口协议的，通过对窗口大小的调整来调整发送的速率。窗口调整的基本策略是当没有发生拥塞的时候加性增而发生拥塞的时候乘性减即AIMD(additive increase，multiplicative decrease)。TCP的拥塞窗口调节，分为慢启动阶段和拥塞避免阶段，慢启动阶段窗口从一个MSS快速增长，到达某个阈值以后转为拥塞避免阶段。  
TCP维持一个称为拥塞窗口的变量CongWin，单位为字节，用于表示在未收到接收端确认的情况下，可以连续发送的数据字节数，这个窗口变量根据上面说的AIMD来调节。  
TCP是根据是否发生了定时器超时或者某个报文段的三次重复确认来判断是否发生了拥塞的。  
TCP的拥塞控制算法包括4个部分：
- 慢启动
- 拥塞避免
- 快速重传
- 快速恢复  
慢启动：慢启动的原理是当TCP连接刚建立的时候不适合一下子发送大量的数据，这样在不知道网络的情况下容易导致网络的拥塞。通常的做法是刚开始发送数据的时候先将CongWin设置成一个MSS的数值，每次收到确认就增加一个MSS。并且会设置一个拥塞窗口的阀值Threshold避免一直无限制的增长下去，到达阈值以后就启动拥塞避免的算法。  
拥塞避免：当进入拥塞避免阶段的话，如果定时器超时的话TCP会设置新的阈值和新的拥塞窗口大小，新的阈值为当前的拥塞窗口的一半而拥塞窗口的大小直接设置为一个MSS即重新执行慢启动。  
快速恢复：上面讨论了定时器超时后拥塞避免阶段要做的事情，接下来说说当收到3次重复的ACK时启动快速重传，这时TCP会认为发生拥塞但是拥塞情况不是很严重因为还收到多个重复ACK，所以这时TCP将阈值调整为当前拥塞窗口的一般而拥塞窗口也减为当前的拥塞窗口的一半直接从拥塞避免阶段开始增长。



     




